module CCPTrigger where

import DA.Action
import DA.Optional
import DA.List
import DA.Foldable hiding (elem, null, foldl)
import DA.Next.Set (Set)
import qualified DA.Next.Set as Set
import Daml.Trigger

import DA.Finance.Asset
import DA.Finance.Types

import Marketplace.Trading
import Marketplace.CentralCounterparty
import Marketplace.Clearing
import Marketplace.CentralCounterpartyCustomer

import Marketplace.Utils

import Utils

data CCPState = CCPState {
   operatorParty : Party
  ,usedDepositCids : [ContractId AssetDeposit]
 }

handleCCP : Trigger CCPState
handleCCP = Trigger
  { initialize = return $ CCPState (fromSome $ partyFromText "Operator") []
  , updateState = \_ -> pure ()
  , rule = handleCCPRule
  , registeredTemplates = RegisteredTemplates  [ registeredTemplate @CCP
                                               , registeredTemplate @CCPCustomer
                                               , registeredTemplate @AssetDeposit
                                               , registeredTemplate @DerivativeTrade
                                               , registeredTemplate @MarginCalculation
                                               , registeredTemplate @MarkToMarketCalculation ]
  , heartbeat = None
  }

-- |Accept 'DepositTransferRequest' and 'CustodianRelationshipRequest'
handleCCPRule : Party -> TriggerA CCPState ()
handleCCPRule party = do
  debug "Running ccp rule..."
  state <- get
  void $ put state { usedDepositCids = [] }

  -- > Set Operator
  ccpRoles <- query @CCP
  forA_ ccpRoles
    $ \(_,ccp) -> void $ put (state { operatorParty = ccp.operator })
               >> debug ("Setting operator party to: " <> show ccp.operator)

  -- > Handle DerivativeTrades
  derivativeTrades <- query @DerivativeTrade
  forA_ derivativeTrades
    $ \(cid,dt) -> dedupExerciseByKey @CCP (state.operatorParty,party)
                    CCP_NovateDerivativeTrade { derivativeTradeCid = cid }
               >> debug ("Novating trade: " <> show dt)

  -- > Handle MarginCalculation
  marginCalculations <- query @MarginCalculation
  forA_ marginCalculations (handleMarginCalculation party)

  -- > Handle MarkToMarketCalculation
  markToMarketCalculations <- query @MarkToMarketCalculation
  let incomingMarkToMarkets = filter (\(_,mtm) -> mtm.mtmAmount < 0.0) markToMarketCalculations
      outgoingMarkToMarkets = filter (\(_,mtm) -> mtm.mtmAmount > 0.0) markToMarketCalculations

  assetDeposits <- query @AssetDeposit
  let ownedAssetDeposits    = filter (\(_,ad) -> ad.account.owner == party) assetDeposits
      providerAssetDeposits = filter (\(_,ad) -> ad.account.provider == party) assetDeposits
  -- forA_ providerAssetDeposits (handleProviderDeposits party)

  forA_ incomingMarkToMarkets (handleIncomingMarkToMarketCalculation party)
  handleOutgoingMTMCalculations party ownedAssetDeposits outgoingMarkToMarkets


getCustomerDeposits : Party -> Party -> TriggerA CCPState [ContractId AssetDeposit]
getCustomerDeposits ccp customer = do
    state@CCPState { operatorParty, usedDepositCids } <- get
    (_,ccpCustomer) <- fromSomeNote "getCustomerDeposits" <$> queryContractKey @CCPCustomer (ccp,operatorParty,customer)
    map fst . filter (\(dCid,d) -> d.account.owner == customer && d.account.provider == ccp && dCid `notElem` ccpCustomer.marginDepositCids) <$> query @AssetDeposit

-- -- |Add any new deposits into a customer's clearing account | TODO: make this perform better
-- handleProviderDeposits : Party -> ContractPair AssetDeposit -> TriggerA CCPState ()
-- handleProviderDeposits ccp (depositCid,deposit) = do
--   CCPState { operatorParty } <- get
--   optCustomer <- queryContractKey @CCPCustomer (ccp,operatorParty,deposit.account.owner)
--   case optCustomer of
--       (Some (ccpCustomerCid,ccpCustomer)) ->
--         unless (depositCid `elem` ccpCustomer.clearingDepositCids || depositCid `elem` ccpCustomer.marginDepositCids)
--           $ dedupExercise ccpCustomerCid CCPCustomer_AddDepositToClearingDeposits with depositCid >> debug ("moving deposit: " <> show deposit)
--       None -> return ()


handleMarginCalculation : Party -> ContractPair MarginCalculation -> TriggerA CCPState ()
handleMarginCalculation ccp (mcCid, mc@MarginCalculation{customer, targetAmount}) = do
  debug ("resolving margin calculation: " <> show mc)
  CCPState { operatorParty } <- get
  -- (ccpCustomerCid,ccpCustomer) <- fromSome <$> queryContractKey @CCPCustomer (ccp,operatorParty,customer)
  clearingDepositCids <- getCustomerDeposits ccp customer
  emitCommands [exerciseByKeyCmd @CCPCustomer (ccp, operatorParty, customer) CCPCustomer_PerformMarginFill
    with calculationCid = mcCid, clearingDepositCids, targetAmount] ([toAnyContractId mcCid] <> map toAnyContractId clearingDepositCids)
  -- dedupExerciseByKey @CCPCustomer (ccp,operatorParty,customer) CCPCustomer_PerformMarginFill with
  --     calculationCid = mcCid, clearingDepositCids, targetAmount

  return ()

  where
    depositIsAccount : Id -> ContractPair AssetDeposit -> Bool
    depositIsAccount accountId (_,deposit) = deposit.account.id == accountId


handleIncomingMarkToMarketCalculation
  : Party
  -> ContractPair MarkToMarketCalculation
  -> TriggerA CCPState ()
handleIncomingMarkToMarketCalculation ccp (mtmCid, mtm@MarkToMarketCalculation { accountId, customer, mtmAmount }) = do
  debug ("handling incoming mtm calculation: " <> show mtm)
  CCPState { operatorParty } <- get
  -- (ccpCustomerCid,ccpCustomer) <- fromSome <$> queryContractKey @CCPCustomer (ccp,operatorParty,customer)
  clearingDepositCids <- getCustomerDeposits ccp customer
  -- unless (null clearingDepositCids) $ do
  emitCommands [exerciseByKeyCmd @CCPCustomer (ccp,operatorParty,customer) CCPCustomer_TransferFromClearingAccount with
    amount = (mtmAmount * (-1.0)), clearingDepositCids, optMarkToMarketCalc = Some mtmCid] (toAnyContractId mtmCid :: map toAnyContractId clearingDepositCids)
  return ()
  -- dedupExerciseByKey @CCPCustomer (ccp,operatorParty,customer) CCPCustomer_TransferFromClearingAccount with
  --   amount = (mtmAmount * (-1.0)), clearingDepositCids, optMarkToMarketCalc = Some mtmCid
      -- dedupExercise mtmCid MarkToMarketCalculation_Resolve with note = "resolved"


handleOutgoingMTMCalculations
  : Party
  -> [ContractPair AssetDeposit]
  -> [ContractPair MarkToMarketCalculation]
  -> TriggerA CCPState ()
handleOutgoingMTMCalculations _     [] _           = return ()
handleOutgoingMTMCalculations _     _  []          = return ()
handleOutgoingMTMCalculations party ds (mtm::mtms) = case ds' of
    None -> do
      debug ("skipping: " <> show mtm)
      handleOutgoingMTMCalculations party ds mtms
    (Some (toUse,remaining)) -> do
      debug ("resolving outgoing mtm calculation: " <> show (snd mtm))
      CCPState { operatorParty } <- get
      debug ("using: " <> show toUse)
      dedupExerciseByKey @CCPCustomer (party,operatorParty,(snd mtm).customer) CCPCustomer_TransferToClearingAccount
          with depositCids = (map fst $ toUse), amount
      dedupExercise (fst mtm) MarkToMarketCalculation_Resolve with note = "resolved"
      handleOutgoingMTMCalculations party remaining mtms
  where
    amount = (snd mtm).mtmAmount
    ds' = getEnoughDeposits amount ([],ds)


getEnoughDeposits
  :  Decimal
  -> ([ContractPair AssetDeposit], [ContractPair AssetDeposit])
  -> Optional ([ContractPair AssetDeposit], [ContractPair AssetDeposit])
getEnoughDeposits restFunds (used,[])
  | restFunds <= 0.0 = Some (used,[])
  | otherwise        = None

getEnoughDeposits restFunds (used,remaining)
  | restFunds <= 0.0 = Some (used,remaining)
  | otherwise = getEnoughDeposits (restFunds - nextAmount)
                                  ((nextDeposit :: used),(tail remaining))
  where
    nextDeposit = headNote "getEnoughDeposits" remaining
    nextAmount  = (.asset.quantity) $ snd $ nextDeposit
