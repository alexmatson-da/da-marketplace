module CCPTrigger where

import DA.Action
import DA.Optional
import DA.List
import DA.Foldable hiding (elem, null, foldl)
import Daml.Trigger

import DA.Finance.Asset
import DA.Finance.Types

import Marketplace.Trading
import Marketplace.CentralCounterparty
import Marketplace.Clearing
import Marketplace.CentralCounterpartyCustomer

import Marketplace.Utils

import Utils

data CCPState = CCPState {
   operatorParty : Party
  ,usedDepositCids : [ContractId AssetDeposit]
 }

handleCCP : Trigger CCPState
handleCCP = Trigger
  { initialize = return $ CCPState (fromSome $ partyFromText "Operator") []
  , updateState = \_ -> pure ()
  , rule = handleCCPRule
  , registeredTemplates = RegisteredTemplates  [ registeredTemplate @CCP
                                               , registeredTemplate @CCPCustomer
                                               , registeredTemplate @AssetDeposit
                                               , registeredTemplate @DerivativeTrade
                                               , registeredTemplate @MarginCalculation
                                               , registeredTemplate @MarkToMarketCalculation ]
  , heartbeat = None
  }

-- |Accept 'DepositTransferRequest' and 'CustodianRelationshipRequest'
handleCCPRule : Party -> TriggerA CCPState ()
handleCCPRule party = do
  debug "Running ccp rule..."
  state <- get
  void $ put state { usedDepositCids = [] }

  -- > Set Operator
  ccpRoles <- query @CCP
  forA_ ccpRoles
    $ \(_,ccp) -> void $ put (state { operatorParty = ccp.operator })
               >> debug ("Setting operator party to: " <> show ccp.operator)

  -- > Handle DerivativeTrades
  derivativeTrades <- query @DerivativeTrade
  forA_ derivativeTrades
    $ \(cid,dt) -> dedupExerciseByKey @CCP (state.operatorParty,party)
                    CCP_NovateDerivativeTrade { derivativeTradeCid = cid }
               >> debug ("Novating trade: " <> show dt)

  -- > Handle MarginCalculation
  marginCalculations <- query @MarginCalculation
  forA_ marginCalculations (handleMarginCalculation party)

  -- > Handle MarkToMarketCalculation
  markToMarketCalculations <- query @MarkToMarketCalculation
  let incomingMarkToMarkets = filter (\(_,mtm) -> mtm.mtmAmount < 0.0) markToMarketCalculations
      outgoingMarkToMarkets = filter (\(_,mtm) -> mtm.mtmAmount > 0.0) markToMarketCalculations

  assetDeposits <- query @AssetDeposit
  let ownedAssetDeposits    = filter (\(_,ad) -> ad.account.owner == party) assetDeposits
      providerAssetDeposits = filter (\(_,ad) -> ad.account.provider == party) assetDeposits
  -- forA_ providerAssetDeposits (handleProviderDeposits party)

  forA_ incomingMarkToMarkets (handleIncomingMarkToMarketCalculation party)
  handleOutgoingMTMCalculations party ownedAssetDeposits outgoingMarkToMarkets


getCustomerDeposits : Party -> Party -> TriggerA CCPState [ContractId AssetDeposit]
getCustomerDeposits ccp customer = do
    state@CCPState { operatorParty, usedDepositCids } <- get
    (_,ccpCustomer) <- fromSomeNote "getCustomerDeposits" <$> queryContractKey @CCPCustomer (ccp,operatorParty,customer)
    map fst . filter (\(dCid,d) -> d.account.owner == customer && d.account.provider == ccp && dCid `notElem` ccpCustomer.marginDepositCids) <$> query @AssetDeposit


handleMarginCalculation : Party -> ContractPair MarginCalculation -> TriggerA CCPState ()
handleMarginCalculation ccp (mcCid, mc@MarginCalculation{customer, targetAmount}) = do
  debug ("resolving margin calculation: " <> show mc)
  CCPState { operatorParty } <- get

  clearingDepositCids <- getCustomerDeposits ccp customer
  emitCommands [exerciseByKeyCmd @CCPCustomer (ccp, operatorParty, customer) CCPCustomer_PerformMarginFill with
                   calculationCid = mcCid, clearingDepositCids, targetAmount]
               ([toAnyContractId mcCid] <> map toAnyContractId clearingDepositCids)

  return ()

  where
    depositIsAccount : Id -> ContractPair AssetDeposit -> Bool
    depositIsAccount accountId (_,deposit) = deposit.account.id == accountId


handleIncomingMarkToMarketCalculation
  : Party
  -> ContractPair MarkToMarketCalculation
  -> TriggerA CCPState ()
handleIncomingMarkToMarketCalculation ccp (mtmCid, mtm@MarkToMarketCalculation { accountId, customer, mtmAmount }) = do
  debug ("handling incoming mtm calculation: " <> show mtm)
  CCPState { operatorParty } <- get
  clearingDepositCids <- getCustomerDeposits ccp customer
  emitCommands [exerciseByKeyCmd @CCPCustomer (ccp,operatorParty,customer) CCPCustomer_TransferFromClearingAccount with
                  amount = (mtmAmount * (-1.0)), clearingDepositCids, optMarkToMarketCalc = Some mtmCid]
               (toAnyContractId mtmCid :: map toAnyContractId clearingDepositCids)
  return ()


handleOutgoingMTMCalculations
  : Party
  -> [ContractPair AssetDeposit]
  -> [ContractPair MarkToMarketCalculation]
  -> TriggerA CCPState ()
handleOutgoingMTMCalculations _     [] _           = return ()
handleOutgoingMTMCalculations _     _  []          = return ()
handleOutgoingMTMCalculations party ds (mtm::mtms) = case ds' of
    None -> handleOutgoingMTMCalculations party ds mtms
    (Some (toUse,remaining)) -> do
      debug ("resolving outgoing mtm calculation: " <> show (snd mtm))
      CCPState { operatorParty } <- get
      dedupExerciseByKey @CCPCustomer (party,operatorParty,(snd mtm).customer) CCPCustomer_TransferToClearingAccount
          with depositCids = map fst toUse, optMarkToMarketCalc = Some (fst mtm), amount
      -- dedupExercise (fst mtm) MarkToMarketCalculation_Resolve with note = "resolved"
      handleOutgoingMTMCalculations party remaining mtms
  where
    amount = (snd mtm).mtmAmount
    ds' = collectDeposits amount ([],ds)


collectDeposits
  :  Decimal
  -> ([ContractPair AssetDeposit], [ContractPair AssetDeposit])
  -> Optional ([ContractPair AssetDeposit], [ContractPair AssetDeposit])
collectDeposits restFunds (used,[])
  | restFunds <= 0.0 = Some (used,[])
  | otherwise        = None

collectDeposits restFunds (used,remaining)
  | restFunds <= 0.0 = Some (used,remaining)
  | otherwise = collectDeposits (restFunds - nextAmount)
                                ((nextDeposit :: used),(tail remaining))
  where
    nextDeposit = headNote "collectDeposits" remaining
    nextAmount = (.asset.quantity) . snd $ nextDeposit
