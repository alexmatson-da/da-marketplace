module Marketplace.Settlement where

import DA.Assert
import DA.Finance.Asset (AssetDeposit)
import DA.Finance.Trade.Dvp (Dvp(..))
import DA.Finance.Trade.SettlementInstruction (SettlementInstruction(..), SettlementInstruction_Process(..))
import DA.Finance.Trade.Types (SettlementStatus(..))
import DA.Finance.Utils (assertOnOrAfterDateMsg, zipChecked, fetchAndArchive)
import DA.List (head, last)
import DA.Optional (whenSome)

template Service
  with
    operator : Party
    provider : Party
  where
    signatory operator, provider

    key (operator, provider) : (Party, Party)
    maintainer key._1

    controller provider can
      nonconsuming SettleTrade : (ContractId Dvp, [[ContractId AssetDeposit]], [[ContractId AssetDeposit]])
        with
          dvpCid : ContractId Dvp
            -- ^ Dvp trade to be settled
          deliveryInstructionCids : [ContractId SettlementInstruction]
            -- ^ Fully allocated settlement instruction for each delivery asset.
          paymentInstructionCids : [ContractId SettlementInstruction]
            -- ^ Fully allocated settlement instruction for each payment asset.
        do
          dvp <- fetchAndArchive dvpCid
          dvp.status === SettlementStatus_Instructed
          whenSome dvp.settlementDate (assertOnOrAfterDateMsg "expects settlementDate <= now")

          let seller = if dvp.buyer == dvp.masterAgreement.party1 then dvp.masterAgreement.party2 else dvp.masterAgreement.party1

          let work sender receiver (asset, instructionCid) = do
                instruction <- fetch instructionCid
                instruction.masterAgreement === dvp.masterAgreement
                instruction.tradeId === dvp.tradeId
                instruction.asset === asset
                (head instruction.steps).senderAccount.owner === sender
                (last instruction.steps).receiverAccount.owner === receiver
                exercise instructionCid SettlementInstruction_Process

          dvpNewCid <- create dvp with status = SettlementStatus_Settled
          paymentDepositCids <- mapA (work dvp.buyer seller) $ zipChecked dvp.payments paymentInstructionCids
          deliveryDepositCids <- mapA (work seller dvp.buyer) $ zipChecked dvp.deliveries deliveryInstructionCids
          pure (dvpNewCid, paymentDepositCids, deliveryDepositCids)

template Offer
  with
    operator : Party
    provider : Party
  where
    signatory operator

    controller provider can
      Accept : ContractId Service
        do
          create Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    provider : Party
    operator : Party
  where
    signatory provider

    controller operator can
      Approve : ContractId Service
        do
          create Service with ..

      Reject : ()
        do
          return ()
