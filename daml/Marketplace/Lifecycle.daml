module Marketplace.Lifecycle where
-- Aka Asset Servicing

import DA.Finance.Types (Id)
import DA.Finance.Asset (AssetDeposit)
import DA.Finance.Asset.Settlement (AssetSettlementRule, AssetSettlement_Transfer(..))
import Marketplace.AssetClaims (Claims)
import ContingentClaims.Claim (deserialize)
import ContingentClaims.Lifecycle (settle)
import DA.Date (toDateUTC)

template Service
  with
    operator: Party
    provider: Party
    client: Party
    assetId: Id -- Is this too granular?
    issuerAccountId: ContractId AssetDeposit
    -- ^ The account from which dividends/coupons are paid
  where
    signatory operator, provider, client

    key (operator, provider, assetId): (Party, Party, Id)
    maintainer key._1

    controller provider can
      nonconsuming Payout: [ContractId AssetDeposit]
        with
          assetServicingSettlementRuleCid: ContractId AssetSettlementRule
          -- ^ Used for payouts e.g. dividend/coupon into asset servicing account
          assetSettlementRuleCid: ContractId AssetSettlementRule
          depositCid: ContractId AssetDeposit
            do
              t <- toDateUTC <$> getTime
              deposit <- fetch depositCid
              payoutSettlementRule <- fetch assetServicingSettlementRuleCid
              let fop : Id -> Decimal -> Date -> Update (ContractId AssetDeposit)
                  fop asset qty dt =
                    exercise assetServicingSettlementRuleCid AssetSettlement_Transfer with
                      receiverAccountId = payoutSettlementRule.account.id
                      depositCid = issuerAccountId
              payouts <- settle fop undefined undefined t
              -- replace the original asset deposit with one that has updated claims
              pure payouts

    controller client can
      nonconsuming MakeElection: ContractId AssetDeposit
        with deposit: ContractId AssetDeposit, election: Claims
          do undefined
