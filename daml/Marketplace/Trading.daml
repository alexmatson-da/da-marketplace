module Marketplace.Trading where

import DA.Finance.Asset
import DA.Finance.Asset.Settlement
import DA.Finance.Types

data Side
    = Buy
    | Sell
  deriving (Eq, Show)

data OrderType
    = Market
    | Limit with
        price : Decimal
  deriving (Eq, Show)

data TimeInForce
    = GTC
      -- ^ Good Till Cancelled
      --  Rests on book until cancellation
    | GTD with
        expiryDate : Date
      -- ^ Good Till Date
      --  At expiryDate, order will be automatically cancelled
    | GAA
      -- ^ Good At Auction
      --  Expires after auction if not filled
    | IOC
      -- ^ Immediate Or Cancel
      --  Allows for partial fills
    | FOK
      -- ^ Fill Or Kill
      --  All or nothing
  deriving (Eq, Show)

data OrderDetails = OrderDetails with
    market : Text
    asset : Asset
    side : Side
    orderType : OrderType
    timeInForce : TimeInForce
  deriving (Eq, Show)

data Status
    = New
    | PendingExecution
    | PartiallyExecuted
    | FullyExecuted
    | Rejected with
        errorCode : Int
        errorMessage : Text
    | PendingCancellation
    | CancellationRejected with
        errorCode : Int
        errorMessage : Text
    | Cancelled
  deriving (Eq, Show)

template Order
  with
    id : Id
    exchange : Party
    client : Party
    exchangeOrderId : Optional Int
    orderDetails : OrderDetails
    status : Status
    depositCid : ContractId AssetDeposit
  where
    signatory exchange, client

    key id : Id
    maintainer key.signatories

template Service
  with
    operator : Party
    exchange : Party
    client : Party
    tradingAccountId : Id
    allocationAccountId : Id
  where
    signatory operator, exchange, client

    key (operator, exchange, client) : (Party, Party, Party)
    maintainer key._1

    controller client can
      nonconsuming RequestCreateOrder : (ContractId Order, ContractId CreateOrderRequest, ContractId AssetDeposit)
        with
          orderId : Id
          orderDetails : OrderDetails
          depositCid : ContractId AssetDeposit
        do
          -- TODO: Check that price and quantity conform to the precision requirements of the Listing
          -- TODO: Check order valid for exberry with the market/limit and timeInForce combos
          let
            status = New
            exchangeOrderId = None
            id = orderId
          depositCid <- exerciseByKey @AssetSettlementRule tradingAccountId AssetSettlement_Transfer with receiverAccountId = allocationAccountId; ..
          createOrderRequestCid <- create CreateOrderRequest with ..
          orderCid <- create Order with ..

          return (orderCid, createOrderRequestCid, depositCid)

      nonconsuming RequestCancelOrder : (ContractId Order, ContractId CancelOrderRequest)
        with
          orderCid : ContractId Order
        do
          order@Order{..} <- fetch orderCid
          archive orderCid

          orderCid <- create order with status = PendingCancellation
          cancelOrderRequestCid <- create CancelOrderRequest with orderId = id; ..

          return (orderCid, cancelOrderRequestCid)

    controller exchange can
      nonconsuming AcknowledgeOrderRequest : ContractId Order
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          exchangeOrderId : Int
        do
          CreateOrderRequest{orderId} <- fetch createOrderRequestCid
          archive createOrderRequestCid
          (orderCid, order) <- fetchByKey orderId

          case order.status of
            New -> do
              archive orderCid
              create order with status = PendingExecution; exchangeOrderId = Some exchangeOrderId
            _ -> return orderCid

      nonconsuming CancelOrder : (ContractId Order, ContractId AssetDeposit)
        with
          cancelOrderRequestCid : ContractId CancelOrderRequest
        do
          CancelOrderRequest{orderId} <- fetch cancelOrderRequestCid
          archive cancelOrderRequestCid
          (orderCid, order) <- fetchByKey orderId
          archive orderCid

          orderCid <- create order with status = Cancelled
          depositCid <- exerciseByKey @AssetSettlementRule allocationAccountId AssetSettlement_Transfer with receiverAccountId = tradingAccountId; depositCid = order.depositCid

          return (orderCid, depositCid)

      nonconsuming RejectOrder : (ContractId Order, ContractId AssetDeposit)
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          errorCode : Int
          errorMessage : Text
        do
          CreateOrderRequest{..} <- fetch createOrderRequestCid
          archive createOrderRequestCid
          (orderCid, order) <- fetchByKey orderId
          archive orderCid

          orderCid <- create order with status = Rejected with ..
          depositCid <- exerciseByKey @AssetSettlementRule allocationAccountId AssetSettlement_Transfer with receiverAccountId = tradingAccountId, ..

          return (orderCid, depositCid)

      nonconsuming RejectCancellation : (ContractId Order)
        with
          cancelOrderRequestCid : ContractId CancelOrderRequest
          errorCode : Int
          errorMessage : Text
        do
          CancelOrderRequest{orderId} <- fetch cancelOrderRequestCid
          archive cancelOrderRequestCid
          (orderCid, order) <- fetchByKey orderId
          archive orderCid

          create order with status = CancellationRejected with ..

      -- nonconsuming FillOrder : ContractId AssetDeposit
      --   with
      --     orderCid : ContractId CancelOrderRequest
      --   do
      --     CancelOrderRequest{..} <- fetch cancelOrderRequestCid
      --     archive cancelOrderRequestCid
      --     order <- fetch orderCid
      --     archive orderCid
      --     exerciseByKey @AssetSettlementRule allocationAccountId AssetSettlement_Transfer with depositCid = order.depositCid; receiverAccountId = tradingAccountId

template Offer
  with
    operator : Party
    exchange : Party
    client : Party
  where
    signatory operator, exchange

    controller client can
      Accept : ContractId Service
        with
          tradingAccountId : Id
          allocationAccountId : Id
        do
          -- TODO: Check necessary conditions, ie. both are visibe to the exchange and exchange is nominee on allocationAccount
          create Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    operator : Party
    client : Party
    exchange : Party
    tradingAccountId : Id
    allocationAccountId : Id
  where
    signatory operator, client

    controller exchange can
      Approve : ContractId Service
        do
          -- TODO: Check necessary conditions, ie. both are visibe to the exchange and exchange is nominee on allocationAccount
          create Service with ..

      Reject : ()
        do
          return ()

template CreateOrderRequest
  with
    exchange : Party
    client : Party
    operator : Party
    orderDetails : OrderDetails
    orderId : Id
    depositCid : ContractId AssetDeposit
  where
    signatory exchange, client

    controller exchange can
      nonconsuming AcknowledgeRequest : ContractId Order
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          exchangeOrderId : Int
        do
          exerciseByKey @Service (operator, exchange, client) AcknowledgeOrderRequest with ..

      nonconsuming RejectRequest : (ContractId Order, ContractId AssetDeposit)
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          errorCode : Int
          errorMessage : Text
        do
          exerciseByKey @Service (operator, exchange, client) RejectOrder with ..

template CancelOrderRequest
  with
    exchange : Party
    client : Party
    operator : Party
    exchangeOrderId : Optional Int
    orderId : Id
  where
    signatory exchange, client

    key (exchange, client, orderId) : (Party, Party, Id)
    maintainer key._1

    controller exchange can
      nonconsuming AcknowledgeCancel : (ContractId Order, ContractId AssetDeposit)
        do
          exerciseByKey @Service (operator, exchange, client) CancelOrder with cancelOrderRequestCid = self

      nonconsuming FailureCancel : ContractId Order
        with
          errorCode : Int
          errorMessage : Text
        do
          exerciseByKey @Service (operator, exchange, client) RejectCancellation with cancelOrderRequestCid = self, ..


-- TODO: Revisit/reimplement


-- template TradeSide
--   with
--     exchParticipant : Party
--     exchange : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     orderId : Int
--     counterOrderId : Int
--     timestamp : Text
--     optAsset : Optional Asset
--     receiverAccountId : Id
--     isBinaryOption : Bool
--   where
--     signatory exchange, exchParticipant

    -- controller exchange can
    --   TradeSide_Settle : (ContractId SettledTradeSide, Optional (ContractId DepositCreditRequest))
    --     do
    --       assert $ not isBinaryOption
    --       optDepositTxReqCid <- case optAsset of
    --         Some asset -> do
    --           let (receiver, receiverProvider) = getAccountOwnerProvider receiverAccountId.label
    --               receiverAccount = Account with id = receiverAccountId, provider = receiverProvider, owner = receiver
    --           creditRequestCid <- create DepositCreditRequest
    --               with owner = exchange
    --                    account = receiverAccount
    --                    asset = asset
    --           return $ Some creditRequestCid
    --         None -> return None
    --       settledTradeCid <- create SettledTradeSide with ..
    --       return (settledTradeCid, optDepositTxReqCid)

    --   TradeSide_SettleBinaryOption : (ContractId SettledTradeSide, Optional (ContractId DepositCreditRequest))
    --     with
    --       settledBinOptionCid : ContractId SettledBinaryOption
    --     do
    --       assert isBinaryOption
    --       settledBinOption <- fetch settledBinOptionCid
    --       let needsTransfer = settledBinOption.outcome /= isBuy
    --       optCreditRequestCid <- case (optAsset, needsTransfer) of
    --         (Some asset, True) -> do
    --           let (receiver, receiverProvider) = getAccountOwnerProvider receiverAccountId.label
    --               receiverAccount = Account with id = receiverAccountId, provider = receiverProvider, owner = receiver
    --           creditRequestCid <- create DepositCreditRequest
    --               with owner = exchange
    --                    account = receiverAccount
    --                    asset = asset
    --           return $ Some creditRequestCid
    --         _ -> return None
    --       settledTradeCid <- create SettledTradeSide with ..
    --       return (settledTradeCid, optCreditRequestCid)


-- template SettledTradeSide
--   with
--     exchParticipant : Party
--     exchange : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     orderId : Int
--     counterOrderId : Int
--     timestamp : Text
--   where
--     signatory exchange, exchParticipant


-- template BrokerTrade
--   with
--     brokerCustomer : Party
--     broker : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     brokerOrderId : Int
--   where
--     signatory broker, brokerCustomer
