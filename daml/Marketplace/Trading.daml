module Marketplace.Trading where

import DA.Finance.Asset
import DA.Finance.Asset.Settlement
import DA.Finance.Types

data Side
    = Buy
    | Sell
  deriving (Eq, Show)

data OrderType
    = Market
    | Limit with
        price : Decimal
  deriving (Eq, Show)

data TimeInForce
    = GoodTillCancelled
      -- ^ Rests on book until cancellation
    | GoodTillDate with
        expiryDate : Date
      -- ^ At expiryDate, order will be automatically cancelled
    | GoodAtAuction
      -- ^ expires after auction if not filled
    | ImmediateOrCancel
      -- ^ Allows for partial fills
    | FillOrKill
      -- ^ All or nothing
  deriving (Eq, Show)

data OrderDetails = OrderDetails with
    market : Text
    asset : Asset
    side : Side
    orderType : OrderType
    timeInForce : TimeInForce
    -- quantity : Decimal -- This means we get the quantity from the Asset...
  deriving (Eq, Show)

template Order
  with
    exchange : Party
    client : Party
    exchangeOrderId : Int
    orderDetails : OrderDetails
    depositCid : ContractId AssetDeposit
  where
    signatory exchange, client

template Service
  with
    operator : Party
    exchange : Party
    client : Party
    tradingAccountId : Id
    allocationAccountId : Id
  where
    signatory operator, exchange, client

    key (operator, exchange, client) : (Party, Party, Party)
    maintainer key._1

    controller client can
      nonconsuming RequestCreateOrder : (ContractId CreateOrderRequest, ContractId AssetDeposit)
        with
          orderDetails : OrderDetails
          depositCid : ContractId AssetDeposit
        do
          -- TODO: Check that price and quantity conform to the precision requirements of the Listing
          -- TODO: Check order valid for exberry with the market/limit and timeInForce combos
          depositCid <- exerciseByKey @AssetSettlementRule tradingAccountId AssetSettlement_Transfer with receiverAccountId = allocationAccountId; ..
          createOrderRequestCid <- create CreateOrderRequest with ..
          pure (createOrderRequestCid, depositCid)

      nonconsuming RequestCancelOrder : ContractId CancelOrderRequest
        with
          orderCid : ContractId Order
        do
          create CancelOrderRequest with ..

    controller exchange can
      nonconsuming CreateOrder : ContractId Order
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          exchangeOrderId : Int
        do
          CreateOrderRequest{..} <- fetch createOrderRequestCid
          archive createOrderRequestCid
          create Order with ..

      nonconsuming CancelOrder : ContractId AssetDeposit
        with
          cancelOrderRequestCid : ContractId CancelOrderRequest
        do
          CancelOrderRequest{..} <- fetch cancelOrderRequestCid
          archive cancelOrderRequestCid
          order <- fetch orderCid
          archive orderCid
          exerciseByKey @AssetSettlementRule allocationAccountId AssetSettlement_Transfer with depositCid = order.depositCid; receiverAccountId = tradingAccountId

      -- nonconsuming FillOrder : ContractId AssetDeposit
      --   with
      --     orderCid : ContractId CancelOrderRequest
      --   do
      --     CancelOrderRequest{..} <- fetch cancelOrderRequestCid
      --     archive cancelOrderRequestCid
      --     order <- fetch orderCid
      --     archive orderCid
      --     exerciseByKey @AssetSettlementRule allocationAccountId AssetSettlement_Transfer with depositCid = order.depositCid; receiverAccountId = tradingAccountId

template Offer
  with
    operator : Party
    exchange : Party
    client : Party
  where
    signatory operator, exchange

    controller client can
      Accept : ContractId Service
        with
          tradingAccountId : Id
          allocationAccountId : Id
        do
          -- TODO: Check necessary conditions, ie. both are visibe to the exchange and exchange is nominee on allocationAccount
          create Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    operator : Party
    client : Party
    exchange : Party
    tradingAccountId : Id
    allocationAccountId : Id
  where
    signatory operator, client

    controller exchange can
      Approve : ContractId Service
        do
          -- TODO: Check necessary conditions, ie. both are visibe to the exchange and exchange is nominee on allocationAccount
          create Service with ..

      Reject : ()
        do
          return ()

template CreateOrderRequest
  with
    exchange : Party
    client : Party
    orderDetails : OrderDetails
    depositCid : ContractId AssetDeposit
  where
    signatory exchange, client

template CancelOrderRequest
  with
    exchange : Party
    client : Party
    orderCid : ContractId Order
  where
    signatory exchange, client


-- TODO: Revisit/reimplement


-- template TradeSide
--   with
--     exchParticipant : Party
--     exchange : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     orderId : Int
--     counterOrderId : Int
--     timestamp : Text
--     optAsset : Optional Asset
--     receiverAccountId : Id
--     isBinaryOption : Bool
--   where
--     signatory exchange, exchParticipant

    -- controller exchange can
    --   TradeSide_Settle : (ContractId SettledTradeSide, Optional (ContractId DepositCreditRequest))
    --     do
    --       assert $ not isBinaryOption
    --       optDepositTxReqCid <- case optAsset of
    --         Some asset -> do
    --           let (receiver, receiverProvider) = getAccountOwnerProvider receiverAccountId.label
    --               receiverAccount = Account with id = receiverAccountId, provider = receiverProvider, owner = receiver
    --           creditRequestCid <- create DepositCreditRequest
    --               with owner = exchange
    --                    account = receiverAccount
    --                    asset = asset
    --           return $ Some creditRequestCid
    --         None -> return None
    --       settledTradeCid <- create SettledTradeSide with ..
    --       return (settledTradeCid, optDepositTxReqCid)

    --   TradeSide_SettleBinaryOption : (ContractId SettledTradeSide, Optional (ContractId DepositCreditRequest))
    --     with
    --       settledBinOptionCid : ContractId SettledBinaryOption
    --     do
    --       assert isBinaryOption
    --       settledBinOption <- fetch settledBinOptionCid
    --       let needsTransfer = settledBinOption.outcome /= isBuy
    --       optCreditRequestCid <- case (optAsset, needsTransfer) of
    --         (Some asset, True) -> do
    --           let (receiver, receiverProvider) = getAccountOwnerProvider receiverAccountId.label
    --               receiverAccount = Account with id = receiverAccountId, provider = receiverProvider, owner = receiver
    --           creditRequestCid <- create DepositCreditRequest
    --               with owner = exchange
    --                    account = receiverAccount
    --                    asset = asset
    --           return $ Some creditRequestCid
    --         _ -> return None
    --       settledTradeCid <- create SettledTradeSide with ..
    --       return (settledTradeCid, optCreditRequestCid)


-- template SettledTradeSide
--   with
--     exchParticipant : Party
--     exchange : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     orderId : Int
--     counterOrderId : Int
--     timestamp : Text
--   where
--     signatory exchange, exchParticipant


-- template BrokerTrade
--   with
--     brokerCustomer : Party
--     broker : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     brokerOrderId : Int
--   where
--     signatory broker, brokerCustomer
