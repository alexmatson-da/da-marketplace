-- TODO DRY: refactor opportunity: embed Order/Trading in these files. 
-- Use proper namespace
module Marketplace.Trading where

import DA.Finance.Asset (AssetDeposit)
import DA.Finance.Asset.Settlement (AssetSettlementRule, AssetSettlement_Transfer(..))
import DA.Finance.Trade.SettlementInstruction (SettlementInstruction(..), SettlementDetails(..))
import DA.Finance.Types (Id, Asset, Account, MasterAgreement)
import DA.Next.Set (empty)

template Order
  with
    provider : Party
    customer : Party
    id : Int
    market : Text
    asset : Asset
    price : Asset
    isBid : Bool
    depositCid : ContractId AssetDeposit
  where
    signatory provider, customer

    controller provider can

      -- TODO: Makeshift implementation to gather customer's signature via this contract
      -- (needed to create the SettlementInstruction)
      -- should probably be done elsewhere / differently
      AllocateSettlementStep : ContractId SettlementInstruction
        with
          masterAgreement : MasterAgreement
          tradeId : Id
          senderAccount : Account
          receiverAccount : Account
          allocatedAsset : Asset
        do
          let steps = [ SettlementDetails with depositCid = Some depositCid; .. ]
          create SettlementInstruction with asset = allocatedAsset; observers = empty; ..

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    tradingAccount : Account
    allocationAccount : Account
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    controller customer can
      nonconsuming RequestCreateOrder : (ContractId CreateOrderRequest, ContractId AssetDeposit)
        with
          market : Text
          asset : Asset
          price : Asset
          isBid : Bool
          depositCid : ContractId AssetDeposit
        do
          -- TODO: Check that price and quantity conform to the precision requirements of the Listing
          depositCid <- exerciseByKey @AssetSettlementRule tradingAccount.id AssetSettlement_Transfer with receiverAccountId = allocationAccount.id; ..
          createOrderRequestCid <- create CreateOrderRequest with ..
          pure (createOrderRequestCid, depositCid)

      nonconsuming RequestCancelOrder : ContractId CancelOrderRequest
        with
          orderCid : ContractId Order
        do
          create CancelOrderRequest with ..

    controller provider can
      nonconsuming CreateOrder : ContractId Order
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          id : Int
        do
          CreateOrderRequest{..} <- fetch createOrderRequestCid
          archive createOrderRequestCid
          create Order with ..

      nonconsuming CancelOrder : ContractId AssetDeposit
        with
          cancelOrderRequestCid : ContractId CancelOrderRequest
        do
          CancelOrderRequest{..} <- fetch cancelOrderRequestCid
          archive cancelOrderRequestCid
          order <- fetch orderCid
          archive orderCid
          exerciseByKey @AssetSettlementRule allocationAccount.id AssetSettlement_Transfer with depositCid = order.depositCid; receiverAccountId = tradingAccount.id

      -- nonconsuming FillOrder : ContractId AssetDeposit
      --   with
      --     orderCid : ContractId CancelOrderRequest
      --   do
      --     CancelOrderRequest{..} <- fetch cancelOrderRequestCid
      --     archive cancelOrderRequestCid
      --     order <- fetch orderCid
      --     archive orderCid
      --     exerciseByKey @AssetSettlementRule allocationAccountId AssetSettlement_Transfer with depositCid = order.depositCid; receiverAccountId = tradingAccountId

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider

    controller customer can
      Accept : ContractId Service
        with
          tradingAccount : Account
          allocationAccount : Account
        do
          -- TODO: Check necessary conditions, ie. both are visibe to the provider and provider is nominee on allocationAccount
          create Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    operator : Party
    customer : Party
    provider : Party
    tradingAccount : Account
    allocationAccount : Account
  where
    signatory operator, customer

    controller provider can
      Approve : ContractId Service
        do
          -- TODO: Check necessary conditions, ie. both are visibe to the provider and provider is nominee on allocationAccount
          create Service with ..

      Reject : ()
        do
          return ()

template CreateOrderRequest
  with
    provider : Party
    customer : Party
    market : Text
    asset : Asset
    price : Asset
    isBid : Bool
    depositCid : ContractId AssetDeposit
  where
    signatory provider, customer

template CancelOrderRequest
  with
    provider : Party
    customer : Party
    orderCid : ContractId Order
  where
    signatory provider, customer
      

-- TODO: Revisit/reimplement


-- template TradeSide
--   with
--     exchParticipant : Party
--     provider : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     orderId : Int
--     counterOrderId : Int
--     timestamp : Text
--     optAsset : Optional Asset
--     receiverAccountId : Id
--     isBinaryOption : Bool
--   where
--     signatory provider, exchParticipant

    -- controller provider can
    --   TradeSide_Settle : (ContractId SettledTradeSide, Optional (ContractId DepositCreditRequest))
    --     do
    --       assert $ not isBinaryOption
    --       optDepositTxReqCid <- case optAsset of
    --         Some asset -> do
    --           let (receiver, receiverProvider) = getAccountOwnerProvider receiverAccountId.label
    --               receiverAccount = Account with id = receiverAccountId, provider = receiverProvider, owner = receiver
    --           creditRequestCid <- create DepositCreditRequest
    --               with owner = provider
    --                    account = receiverAccount
    --                    asset = asset
    --           return $ Some creditRequestCid
    --         None -> return None
    --       settledTradeCid <- create SettledTradeSide with ..
    --       return (settledTradeCid, optDepositTxReqCid)

    --   TradeSide_SettleBinaryOption : (ContractId SettledTradeSide, Optional (ContractId DepositCreditRequest))
    --     with
    --       settledBinOptionCid : ContractId SettledBinaryOption
    --     do
    --       assert isBinaryOption
    --       settledBinOption <- fetch settledBinOptionCid
    --       let needsTransfer = settledBinOption.outcome /= isBuy
    --       optCreditRequestCid <- case (optAsset, needsTransfer) of
    --         (Some asset, True) -> do
    --           let (receiver, receiverProvider) = getAccountOwnerProvider receiverAccountId.label
    --               receiverAccount = Account with id = receiverAccountId, provider = receiverProvider, owner = receiver
    --           creditRequestCid <- create DepositCreditRequest
    --               with owner = provider
    --                    account = receiverAccount
    --                    asset = asset
    --           return $ Some creditRequestCid
    --         _ -> return None
    --       settledTradeCid <- create SettledTradeSide with ..
    --       return (settledTradeCid, optCreditRequestCid)


-- template SettledTradeSide
--   with
--     exchParticipant : Party
--     provider : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     orderId : Int
--     counterOrderId : Int
--     timestamp : Text
--   where
--     signatory provider, exchParticipant


-- template BrokerTrade
--   with
--     brokerCustomer : Party
--     broker : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     brokerOrderId : Int
--   where
--     signatory broker, brokerCustomer
