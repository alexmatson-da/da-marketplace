-- TODO DRY: refactor opportunity: embed Order/Trading in these files.
-- Use proper namespace
module Marketplace.Trading where

import DA.Finance.Asset (AssetDeposit)
import DA.Finance.Asset.Settlement (AssetSettlementRule, AssetSettlement_Transfer(..))
import DA.Finance.Trade.SettlementInstruction (SettlementInstruction(..), SettlementDetails(..))
import DA.Finance.Types (Id, Asset, Account, MasterAgreement)
import DA.Next.Set (empty)

data Side
    = Buy
    | Sell
  deriving (Eq, Show)

data OrderType
    = Market
    | Limit with
        price : Asset
  deriving (Eq, Show)

data TimeInForce
    = GTC
      -- ^ Good Till Cancelled (Rests on book until cancellation)
    | GTD with
        expiryDate : Date
      -- ^ Good Till Date (At expiryDate, order will be automatically cancelled)
    | GAA
      -- ^ Good At Auction (Expires after auction if not filled)
    | IOC
      -- ^ Immediate Or Cancel (Allows for partial fills)
    | FOK
      -- ^ Fill Or Kill (All or nothing)
  deriving (Eq, Show)

data OrderDetails = OrderDetails with
    id : Id
    market : Text
    asset : Asset
    side : Side
    orderType : OrderType
    timeInForce : TimeInForce
  deriving (Eq, Show)

data Status
    = New
    | PendingExecution
    | PartiallyExecuted
    | FullyExecuted
    | Rejected with
        errorCode : Int
        errorMessage : Text
    | PendingCancellation
    | CancellationRejected with
        errorCode : Int
        errorMessage : Text
    | Cancelled
  deriving (Eq, Show)

template Order
  with
    provider : Party
    customer : Party
    orderDetails : OrderDetails
    status : Status
    providerOrderId : Optional Int
    depositCid : ContractId AssetDeposit
  where
    signatory provider, customer

    key orderDetails.id : Id
    maintainer key.signatories

    controller provider can

      -- TODO: Makeshift implementation to gather customer's signature via this contract
      -- (needed to create the SettlementInstruction)
      -- should probably be done elsewhere / differently
      AllocateSettlementStep : ContractId SettlementInstruction
        with
          masterAgreement : MasterAgreement
          tradeId : Id
          senderAccount : Account
          receiverAccount : Account
          allocatedAsset : Asset
        do
          let steps = [ SettlementDetails with depositCid = Some depositCid; .. ]
          create SettlementInstruction with asset = allocatedAsset; observers = empty; ..

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    tradingAccount : Account
    allocationAccount : Account
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    controller customer can
      nonconsuming RequestCreateOrder : (ContractId Order, ContractId CreateOrderRequest, ContractId AssetDeposit)
        with
          orderDetails : OrderDetails
          depositCid : ContractId AssetDeposit
        do
          -- TODO: Check that price and quantity conform to the precision requirements of the Listing
          -- TODO: Check order valid for exberry with the market/limit and timeInForce combos
          let
            status = New
            providerOrderId = None
            id = orderId
          depositCid <- exerciseByKey @AssetSettlementRule tradingAccount.id AssetSettlement_Transfer with receiverAccountId = allocationAccount.id; ..
          createOrderRequestCid <- create CreateOrderRequest with ..
          orderCid <- create Order with ..

          return (orderCid, createOrderRequestCid, depositCid)

      nonconsuming RequestCancelOrder : (ContractId Order, ContractId CancelOrderRequest)
        with
          orderCid : ContractId Order
        do
          order@Order{..} <- fetch orderCid
          archive orderCid

          orderCid <- create order with status = PendingCancellation
          cancelOrderRequestCid <- create CancelOrderRequest with orderId = orderDetails.id; ..

          return (orderCid, cancelOrderRequestCid)

    controller provider can
      nonconsuming AcknowledgeOrderRequest : ContractId Order
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          providerOrderId : Int
        do
          CreateOrderRequest{orderDetails} <- fetch createOrderRequestCid
          archive createOrderRequestCid
          (orderCid, order) <- fetchByKey orderDetails.id

          case order.status of
            New -> do
              archive orderCid
              create order with status = PendingExecution; providerOrderId = Some providerOrderId
            _ -> return orderCid

      nonconsuming CancelOrder : (ContractId Order, ContractId AssetDeposit)
        with
          cancelOrderRequestCid : ContractId CancelOrderRequest
        do
          CancelOrderRequest{orderId} <- fetch cancelOrderRequestCid
          archive cancelOrderRequestCid
          (orderCid, order@Order{..}) <- fetchByKey orderId
          archive orderCid

          orderCid <- create order with status = Cancelled
          depositCid <- exerciseByKey @AssetSettlementRule allocationAccount.id AssetSettlement_Transfer with receiverAccountId = tradingAccount.id; ..

          return (orderCid, depositCid)

      nonconsuming RejectOrder : (ContractId Order, ContractId AssetDeposit)
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          errorCode : Int
          errorMessage : Text
        do
          CreateOrderRequest{..} <- fetch createOrderRequestCid
          archive createOrderRequestCid
          (orderCid, order) <- fetchByKey orderDetails.id
          archive orderCid

          orderCid <- create order with status = Rejected with ..
          depositCid <- exerciseByKey @AssetSettlementRule allocationAccount.id AssetSettlement_Transfer with receiverAccountId = tradingAccount.id, ..

          return (orderCid, depositCid)

      nonconsuming RejectCancellation : (ContractId Order)
        with
          cancelOrderRequestCid : ContractId CancelOrderRequest
          errorCode : Int
          errorMessage : Text
        do
          CancelOrderRequest{orderId} <- fetch cancelOrderRequestCid
          archive cancelOrderRequestCid
          (orderCid, order) <- fetchByKey orderId
          archive orderCid

          create order with status = CancellationRejected with ..

      -- nonconsuming FillOrder : ContractId AssetDeposit
      --   with
      --     orderCid : ContractId CancelOrderRequest
      --   do
      --     CancelOrderRequest{..} <- fetch cancelOrderRequestCid
      --     archive cancelOrderRequestCid
      --     order <- fetch orderCid
      --     archive orderCid
      --     exerciseByKey @AssetSettlementRule allocationAccountId AssetSettlement_Transfer with depositCid = order.depositCid; receiverAccountId = tradingAccountId

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider

    controller customer can
      Accept : ContractId Service
        with
          tradingAccount : Account
          allocationAccount : Account
        do
          -- TODO: Check necessary conditions, ie. both are visibe to the provider and provider is nominee on allocationAccount
          create Service with ..

      Decline : ()
        do
          return ()

template Request
  with
    operator : Party
    customer : Party
    provider : Party
    tradingAccount : Account
    allocationAccount : Account
  where
    signatory operator, customer

    controller provider can
      Approve : ContractId Service
        do
          -- TODO: Check necessary conditions, ie. both are visibe to the provider and provider is nominee on allocationAccount
          create Service with ..

      Reject : ()
        do
          return ()

template CreateOrderRequest
  with
    provider : Party
    customer : Party
    operator : Party
    orderDetails : OrderDetails
    depositCid : ContractId AssetDeposit
  where
    signatory provider, customer

    let serviceKey = (operator, provider, customer)

    controller provider can
      nonconsuming AcknowledgeRequest : ContractId Order
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          providerOrderId : Int
        do
          exerciseByKey @Service serviceKey AcknowledgeOrderRequest with ..

      nonconsuming RejectRequest : (ContractId Order, ContractId AssetDeposit)
        with
          createOrderRequestCid : ContractId CreateOrderRequest
          errorCode : Int
          errorMessage : Text
        do
          exerciseByKey @Service serviceKey RejectOrder with ..

template CancelOrderRequest
  with
    provider : Party
    customer : Party
    operator : Party
    providerOrderId : Optional Int
    orderId : Id
  where
    signatory provider, customer

    key (provider, customer, orderId) : (Party, Party, Id)
    maintainer key._1

    let serviceKey = (operator, provider, customer)

    controller provider can
      nonconsuming AcknowledgeCancel : (ContractId Order, ContractId AssetDeposit)
        do
          exerciseByKey @Service serviceKey CancelOrder with cancelOrderRequestCid = self

      nonconsuming FailureCancel : ContractId Order
        with
          errorCode : Int
          errorMessage : Text
        do
          exerciseByKey @Service serviceKey RejectCancellation with cancelOrderRequestCid = self, ..


-- TODO: Revisit/reimplement


-- template TradeSide
--   with
--     exchParticipant : Party
--     provider : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     orderId : Int
--     counterOrderId : Int
--     timestamp : Text
--     optAsset : Optional Asset
--     receiverAccountId : Id
--     isBinaryOption : Bool
--   where
--     signatory provider, exchParticipant

    -- controller provider can
    --   TradeSide_Settle : (ContractId SettledTradeSide, Optional (ContractId DepositCreditRequest))
    --     do
    --       assert $ not isBinaryOption
    --       optDepositTxReqCid <- case optAsset of
    --         Some asset -> do
    --           let (receiver, receiverProvider) = getAccountOwnerProvider receiverAccountId.label
    --               receiverAccount = Account with id = receiverAccountId, provider = receiverProvider, owner = receiver
    --           creditRequestCid <- create DepositCreditRequest
    --               with owner = provider
    --                    account = receiverAccount
    --                    asset = asset
    --           return $ Some creditRequestCid
    --         None -> return None
    --       settledTradeCid <- create SettledTradeSide with ..
    --       return (settledTradeCid, optDepositTxReqCid)

    --   TradeSide_SettleBinaryOption : (ContractId SettledTradeSide, Optional (ContractId DepositCreditRequest))
    --     with
    --       settledBinOptionCid : ContractId SettledBinaryOption
    --     do
    --       assert isBinaryOption
    --       settledBinOption <- fetch settledBinOptionCid
    --       let needsTransfer = settledBinOption.outcome /= isBuy
    --       optCreditRequestCid <- case (optAsset, needsTransfer) of
    --         (Some asset, True) -> do
    --           let (receiver, receiverProvider) = getAccountOwnerProvider receiverAccountId.label
    --               receiverAccount = Account with id = receiverAccountId, provider = receiverProvider, owner = receiver
    --           creditRequestCid <- create DepositCreditRequest
    --               with owner = provider
    --                    account = receiverAccount
    --                    asset = asset
    --           return $ Some creditRequestCid
    --         _ -> return None
    --       settledTradeCid <- create SettledTradeSide with ..
    --       return (settledTradeCid, optCreditRequestCid)


-- template SettledTradeSide
--   with
--     exchParticipant : Party
--     provider : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     orderId : Int
--     counterOrderId : Int
--     timestamp : Text
--   where
--     signatory provider, exchParticipant


-- template BrokerTrade
--   with
--     brokerCustomer : Party
--     broker : Party
--     pair : IdPair
--     price : Decimal
--     qty : Decimal
--     isBuy : Bool
--     brokerOrderId : Int
--   where
--     signatory broker, brokerCustomer
