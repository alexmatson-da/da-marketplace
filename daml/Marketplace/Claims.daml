{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE UndecidableInstances #-} --needed to derive cofree Show,Eq

module Marketplace.Claims (
    assetDescVers
  , binaryCallOption
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..), serialize, cond, one)
import ContingentClaims.FinancialClaim (european)
import ContingentClaims.Observable qualified as O
import ContingentClaims.Observation (Observation)
import ContingentClaims.Observation qualified as O
import DA.Assert ((===))
import DA.Finance.Types (Id(..))
import Marketplace.AssetDescription (AssetDescription(..))
import Daml.Control.Recursion
import Daml.Script
import Prelude hiding (enumerate, length)

type C = Claim Observation Date Id
type F = ClaimF Observation Date Id

deriving instance Show C
deriving instance Eq C
deriving instance (Show a, Show (f (Cofree f a))) => Show (Cofree f a)
deriving instance (Eq a, Eq (f (Cofree f a))) => Eq (Cofree f a)
deriving instance Show (F (Cofree F Int))
deriving instance Eq (F (Cofree F Int))

assetDescVers: Id 
             -> Text  
             -> Party 
             -> Id 
             -> C -> [Update (ContractId AssetDescription)]
assetDescVers assetId description issuer safekeepingAccountId = 
  ana write . ana zipWithIndex . (assetId.version + 1, ) . para depthFst --TODO: use ghylo
    where
      depthFst : F (C, [C]) -> [C] --only @And@ and @Or@ are included
      depthFst ZeroF = []
      depthFst (OneF _) = []
      depthFst (ScaleF _ (_, cs)) = cs
      depthFst (WhenF _ (_, cs)) = cs
      depthFst (GiveF (_, cs)) = cs
      depthFst (AndF (c, cs) (c', cs')) = c :: cs ++ c' :: cs'
      depthFst (OrF (c, cs) (c', cs')) = c :: cs ++ c' :: cs'
      depthFst (CondF _ (_, cs) (_, cs')) = cs ++ cs'
      zipWithIndex (_, []) = Nil
      zipWithIndex (i, x :: xs) = Cons (i, x) (succ i, xs)
      write : [(Int, C)] -> ListF (Update (ContractId AssetDescription)) [(Int, C)]
      write ((version', claims') :: vcs) =
        let assetId' = assetId with version = version'
            claims = serialize claims'
        in Cons (create AssetDescription with assetId = assetId', ..) vcs
      write [] = Nil

count : F (Cofree F Int) -> Cofree F Int
count ZeroF = Cofree 1 ZeroF
count (OneF id) = Cofree 1 (OneF id)
count f@(WhenF _ (Cofree depth _)) = Cofree (succ depth) f
count f@(ScaleF _ (Cofree depth _)) = Cofree (succ depth) f
count f@(GiveF (Cofree depth _)) = Cofree (succ depth) f
count f@(AndF (Cofree depth _) (Cofree depth' _)) = Cofree (succ $ depth + depth') f
count f@(OrF (Cofree depth _) (Cofree depth' _)) = Cofree (succ $ depth + depth') f
count f@(CondF _ (Cofree depth _) (Cofree depth' _)) = Cofree (succ $ depth + depth') f

enum : (Int, Cofree F Int) -> CofreeF F Int (Int, Cofree F Int)
enum (i, Cofree _ ZeroF) = CofreeF i ZeroF
enum (i, Cofree _ (OneF id)) = CofreeF i (OneF id)
enum (i, Cofree _ (WhenF p f)) = CofreeF i (WhenF p (succ i, f))
enum (i, Cofree _ (ScaleF p f)) = CofreeF i (ScaleF p (succ i, f))
enum (i, Cofree _ (GiveF f)) = CofreeF i (GiveF (succ i, f))
enum (i, Cofree _ (AndF f@(Cofree depth _) f')) = CofreeF i (AndF (succ i, f) (succ (i + depth), f'))
enum (i, Cofree _ (OrF f@(Cofree depth _) f')) = CofreeF i (OrF (succ i, f) (succ (i + depth), f'))
enum (i, Cofree _ (CondF p f@(Cofree depth _) f')) = CofreeF i (CondF p (succ i, f) (succ (i + depth), f'))

enumerateFrom : Int -> C -> Cofree F Int 
enumerateFrom zero = ana enum . (zero, ) . cata count

enumerateTest: Script ()
enumerateTest = do
  let [a,b,c] = Id mempty <$> ["a","b","c"] <*> [0]
  enumerateFrom 0 Zero === Cofree 0 ZeroF
  enumerateFrom 0 (Scale (O.pure 2.0) (One a)) === Cofree 0 (ScaleF (O.pure 2.0) (Cofree 1 (OneF a)))
  enumerateFrom 0 (One a `And` Zero) === Cofree 0 (AndF (Cofree 1 (OneF a)) (Cofree 2 ZeroF))
  enumerateFrom 0 (
    Scale (O.pure 3.0)
      ( And 
        ( And 
          ( Scale (O.pure 5.0) 
            (One a)
          )
          (One b)
        )
        ( And 
          Zero
          (One c)
        )
      )
    ) === 
   ( Cofree 0 (ScaleF (O.pure 3.0)
     ( Cofree 1 ( AndF 
       ( Cofree 2 ( AndF 
         ( Cofree 3 ( ScaleF (O.pure 5.0) 
           ( Cofree 4 (OneF a) )
         ) )
         ( Cofree 5 (OneF b) )
       ) )
       ( Cofree 6 ( AndF 
         ( Cofree 7 ZeroF )
         ( Cofree 8 (OneF c) )
       ) )
     ) )
   ) )

binaryCallOption : Date -> Decimal -> Id -> Id -> C
binaryCallOption expiry strike underlyingId currencyId =
  european expiry (binary strike underlyingId.label currencyId)
    where binary : Decimal -> Text -> Id -> Claim O.Observation Date Id
          binary strike spot ccy = cond (O.pure strike O.<= O.observe spot) (one currencyId) Zero
