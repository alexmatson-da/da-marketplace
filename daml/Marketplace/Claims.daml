module Marketplace.Claims (
    assetDescVers
  , binaryCallOption
  , enumerateFrom
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..), serialize, cond, one)
import ContingentClaims.FinancialClaim (european)
import ContingentClaims.Observable qualified as O
import ContingentClaims.Observation (Observation)
import ContingentClaims.Observation qualified as O
import DA.Finance.Types (Id(..))
import Marketplace.AssetDescription (AssetDescription(..))
import Daml.Control.Recursion

type C = Claim Observation Date Id
type F = ClaimF Observation Date Id

assetDescVers: Id 
             -> Text  
             -> Party 
             -> Id 
             -> C -> [Update (ContractId AssetDescription)]
assetDescVers assetId description issuer safekeepingAccountId = 
  ana write . ana zipWithIndex . (assetId.version + 1, ) . para depthFst --TODO: use ghylo
    where
      depthFst : F (C, [C]) -> [C] --only @And@ and @Or@ are included
      depthFst ZeroF = []
      depthFst (OneF _) = []
      depthFst (ScaleF _ (_, cs)) = cs
      depthFst (WhenF _ (_, cs)) = cs
      depthFst (GiveF (_, cs)) = cs
      depthFst (AndF (c, cs) (c', cs')) = c :: cs ++ c' :: cs'
      depthFst (OrF (c, cs) (c', cs')) = c :: cs ++ c' :: cs'
      depthFst (CondF _ (_, cs) (_, cs')) = cs ++ cs'
      zipWithIndex (_, []) = Nil
      zipWithIndex (i, x :: xs) = Cons (i, x) (succ i, xs)
      write : [(Int, C)] -> ListF (Update (ContractId AssetDescription)) [(Int, C)]
      write ((version', claims') :: vcs) =
        let assetId' = assetId with version = version'
            claims = serialize claims'
        in Cons (create AssetDescription with assetId = assetId', ..) vcs
      write [] = Nil

count : F (Cofree F Int) -> Cofree F Int
count ZeroF = Cofree 1 ZeroF
count (OneF id) = Cofree 1 (OneF id)
count f@(WhenF _ (Cofree depth _)) = Cofree (succ depth) f
count f@(ScaleF _ (Cofree depth _)) = Cofree (succ depth) f
count f@(GiveF (Cofree depth _)) = Cofree (succ depth) f
count f@(AndF (Cofree depth _) (Cofree depth' _)) = Cofree (succ $ depth + depth') f
count f@(OrF (Cofree depth _) (Cofree depth' _)) = Cofree (succ $ depth + depth') f
count f@(CondF _ (Cofree depth _) (Cofree depth' _)) = Cofree (succ $ depth + depth') f

enum : (Int, Cofree F Int) -> CofreeF F Int (Int, Cofree F Int)
enum (i, Cofree _ ZeroF) = CofreeF i ZeroF
enum (i, Cofree _ (OneF id)) = CofreeF i (OneF id)
enum (i, Cofree _ (WhenF p f)) = CofreeF i (WhenF p (succ i, f))
enum (i, Cofree _ (ScaleF p f)) = CofreeF i (ScaleF p (succ i, f))
enum (i, Cofree _ (GiveF f)) = CofreeF i (GiveF (succ i, f))
enum (i, Cofree _ (AndF f@(Cofree depth _) f')) = CofreeF i (AndF (succ i, f) (succ (i + depth), f'))
enum (i, Cofree _ (OrF f@(Cofree depth _) f')) = CofreeF i (OrF (succ i, f) (succ (i + depth), f'))
enum (i, Cofree _ (CondF p f@(Cofree depth _) f')) = CofreeF i (CondF p (succ i, f) (succ (i + depth), f'))

enumerateFrom : Int -> C -> Cofree F Int 
enumerateFrom zero = ana enum . (zero, ) . cata count

binaryCallOption : Date -> Decimal -> Id -> Id -> C
binaryCallOption expiry strike underlyingId currencyId =
  european expiry (binary strike underlyingId.label currencyId)
    where binary : Decimal -> Text -> Id -> Claim O.Observation Date Id
          binary strike spot ccy = cond (O.pure strike O.<= O.observe spot) (one currencyId) Zero
