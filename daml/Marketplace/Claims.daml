module Marketplace.Claims (
    assetDescVers
  , binaryCallOption
  , enumerateFrom
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..), serialize, cond, one)
import ContingentClaims.Lifecycle qualified as Claim
import ContingentClaims.FinancialClaim (european)
import ContingentClaims.Observable qualified as O
import ContingentClaims.Observation (Observation)
import ContingentClaims.Observation qualified as O
import DA.List (dedupSort)
import DA.Finance.Types (Id(..))
import DA.Next.Set (Set)
import Marketplace.AssetDescription (AssetDescription(..))
import Daml.Control.Recursion

type C = Claim Observation Date Id
type F = ClaimF Observation Date Id

assetDescVers: Id
             -> Text
             -> Party
             -> Id
             -> Set Party
             -> C -> [Update (ContractId AssetDescription)]
assetDescVers assetId description issuer safekeepingAccountId observers claims =
  ana stepLifecycle (0, fixingDates, claims)
    where
      fixingDates : [Date] = dedupSort . fixings $ claims
      stepLifecycle : (Int, [Date], C) -> ListF (Update (ContractId AssetDescription)) (Int, [Date], C)
      stepLifecycle (_, [], _) = Nil
      stepLifecycle (version, fixing :: fs, claims') = Cons 
        do
          let runSpot = (error "assetDescVers: runSpot")
              prune : Id -> Decimal -> Date -> Update C
              prune id qty dt = Claim.pruneLeaf runSpot id qty claims' dt
              goLeft = const
           --FIXME multiple settlements on single date?
          [claims] <- Claim.lifecycle prune runSpot goLeft claims' fixing
          create AssetDescription 
            with 
              assetId = assetId with version
              claims = serialize claims
              ..
       (succ version, fs, claims)
       
-- Returns a tree with each node annotated with the # of nodes below it + 1
count : F (Cofree F Int) -> Cofree F Int
count ZeroF = Cofree 1 ZeroF
count (OneF id) = Cofree 1 (OneF id)
count f@(WhenF _ (Cofree depth _)) = Cofree (succ depth) f
count f@(ScaleF _ (Cofree depth _)) = Cofree (succ depth) f
count f@(GiveF (Cofree depth _)) = Cofree (succ depth) f
count f@(AndF (Cofree depth _) (Cofree depth' _)) = Cofree (succ $ depth + depth') f
count f@(OrF (Cofree depth _) (Cofree depth' _)) = Cofree (succ $ depth + depth') f
count f@(CondF _ (Cofree depth _) (Cofree depth' _)) = Cofree (succ $ depth + depth') f

-- Given a tree annotated with the number of nodes in each branch, index it, depth first.
enum : (Int, Cofree F Int) -> CofreeF F Int (Int, Cofree F Int)
enum (i, Cofree _ ZeroF) = CofreeF i ZeroF
enum (i, Cofree _ (OneF id)) = CofreeF i (OneF id)
enum (i, Cofree _ (WhenF p f)) = CofreeF i (WhenF p (succ i, f))
enum (i, Cofree _ (ScaleF p f)) = CofreeF i (ScaleF p (succ i, f))
enum (i, Cofree _ (GiveF f)) = CofreeF i (GiveF (succ i, f))
enum (i, Cofree _ (AndF f@(Cofree depth _) f')) = CofreeF i (AndF (succ i, f) (succ (i + depth), f'))
enum (i, Cofree _ (OrF f@(Cofree depth _) f')) = CofreeF i (OrF (succ i, f) (succ (i + depth), f'))
enum (i, Cofree _ (CondF p f@(Cofree depth _) f')) = CofreeF i (CondF p (succ i, f) (succ (i + depth), f'))

-- Enumerate each node in the tree, starting from from 'zero'
enumerateFrom : Int -> C -> Cofree F Int
enumerateFrom zero = ana enum . (zero, ) . cata count

fixings = cata fixings'

--TODO should fail if dates will never be executed
fixings' : F [Date] -> [Date]
fixings' ZeroF = []
fixings' (OneF _) = []
fixings' (GiveF ts) = ts
fixings' (ScaleF _ ts) = ts
fixings' (WhenF p ts) = O.fixings p ++ ts
fixings' (OrF ts ts') = ts ++ ts'
fixings' (AndF ts ts') = ts ++ ts'
fixings' (CondF _ ts ts') = ts ++ ts'

-- TODO: 'european' creates a superfluous 'Or' node which doesn't really serve any purpose.
binaryCallOption : Date -> Decimal -> Id -> Id -> C
binaryCallOption expiry strike underlyingId currencyId =
  european expiry (binary strike underlyingId.label currencyId)
    where binary : Decimal -> Text -> Id -> Claim O.Observation Date Id
          binary strike spot ccy = cond (O.pure strike O.<= O.observe spot) (one currencyId) Zero
