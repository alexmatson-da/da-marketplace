{-# LANGUAGE MultiWayIf #-}

module Marketplace.Clearing.Service where

import DA.List

import DA.Finance.Asset
import DA.Finance.Asset.Settlement
import DA.Finance.Types

import qualified Marketplace.Rule.AllocationAccount as AllocationAccountRule (T, Deposit(..), Withdraw(..))
import Marketplace.Clearing.Model

import DA.Functor (void)

mergeAndSplit : [ContractId AssetDeposit] -> Decimal -> Update [ContractId AssetDeposit]
mergeAndSplit depositCids amount = do
    depositCid <- exercise (head depositCids) AssetDeposit_Merge with depositCids = tail depositCids
    exercise depositCid AssetDeposit_Split with quantities = [amount]

getDepositQuantities : [ContractId AssetDeposit] -> Update Decimal
getDepositQuantities depositCids = foldl (+) 0.0 <$> forA depositCids (fmap (.asset.quantity) . fetch)

data CalculationResults = CalculationSatisfied
                        | CalculationFailed

isSatisfied : CalculationResults -> Bool
isSatisfied CalculationSatisfied = True
isSatisfied CalculationFailed    = False

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    ccpAccount : Account
    clearingAccount : Account
    marginAccount : Account
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    let
      transferToMarginAccount : ContractId AssetDeposit -> Update (ContractId AssetDeposit)
      transferToMarginAccount = \depositCid -> exerciseByKey @AllocationAccountRule.T marginAccount.id
          AllocationAccountRule.Deposit with ..

      transferFromMarginAccount : ContractId AssetDeposit -> Update (ContractId AssetDeposit)
      transferFromMarginAccount = \depositCid -> exerciseByKey @AllocationAccountRule.T marginAccount.id
          AllocationAccountRule.Withdraw with transferTo = clearingAccount; ..

      resolveMarginCalculation : ContractId MarginCalculation -> CalculationResults -> Text -> Update ()
      resolveMarginCalculation = \calculationCid results note -> do
        exerciseByKey @MemberStanding (provider, customer) MemberStanding_UpdateMargin with
            newMarginSatisfied = isSatisfied results; ..
        case results of
          CalculationSatisfied -> void $ exercise calculationCid MarginCalculation_Resolve with ..
          CalculationFailed    -> void $ exercise calculationCid MarginCalculation_Reject with ..

      resolveMarkToMarketCalculation : ContractId MarkToMarketCalculation -> CalculationResults -> Text -> Update ()
      resolveMarkToMarketCalculation = \calculationCid results note -> do
        exerciseByKey @MemberStanding (provider, customer) MemberStanding_UpdateMTM with
            newMtmSatisied = isSatisfied results; ..
        case results of
          CalculationSatisfied -> void $ exercise calculationCid MarkToMarketCalculation_Resolve with ..
          CalculationFailed    -> void $ exercise calculationCid MarkToMarketCalculation_Reject with ..

      transferWithController : ContractId AssetDeposit -> Account -> Update (ContractId AssetDeposit)
      transferWithController = \depositCid to -> do
          deposit <- fetch depositCid
          let addNominee = exerciseByKey @AssetSettlementRule to.id
                AssetSettlement_AddController with ctrl = deposit.account.owner
              removeNominee = exerciseByKey @AssetSettlementRule to.id
                AssetSettlement_RemoveController with ctrl = deposit.account.owner

          addNominee *>
              exerciseByKey @AssetSettlementRule deposit.account.id
                AssetSettlement_Transfer with receiverAccountId = to.id; ..
            <* removeNominee

    controller provider can
      nonconsuming CreateMarginCalculation : ContractId MarginCalculation
        with
          targetAmount : Decimal
          currency : Text
          calculationId : Text
        do
          calculationTime <- getTime
          create MarginCalculation with ccp = provider; accountId = clearingAccount.id; ..

      nonconsuming CreateMarkToMarket : ContractId MarkToMarketCalculation
        with
          mtmAmount : Decimal
          currency : Text
          calculationId : Text
        do
          calculationTime <- getTime
          create MarkToMarketCalculation with ccp = provider; accountId = clearingAccount.id; ..

      nonconsuming PerformMarginFill : Optional ((ContractId AssetDeposit), [ContractId AssetDeposit])
        with
          depositCids : [ContractId AssetDeposit]
          marginDepositCids : [ContractId AssetDeposit]
          calculationCid : ContractId MarginCalculation
        do
          targetAmount <- (.targetAmount) <$> fetch calculationCid
          depositAmount <- getDepositQuantities depositCids
          marginAmount <- getDepositQuantities marginDepositCids

          let diff = targetAmount - marginAmount
          if diff > 0.0 && depositAmount < diff
          then resolveMarginCalculation calculationCid CalculationFailed "" >> return None
          else do
            resolveMarginCalculation calculationCid CalculationSatisfied ""
            if | diff == 0.0 -> return None
               | diff > 0.0  -> Some <$> exercise self TransferToMargin with amount = diff; ..
               | otherwise   -> Some <$> exercise self TransferFromMargin with amount = (abs diff); ..

      nonconsuming PerformMarkToMarket : Optional (ContractId AssetDeposit, [ContractId AssetDeposit])
        with
          providerDepositCids : [ContractId AssetDeposit]
          customerDepositCids : [ContractId AssetDeposit]
          calculationCid : ContractId MarkToMarketCalculation
        do
          mtmAmount <- (.mtmAmount) <$> fetch calculationCid
          providerAmount <- getDepositQuantities providerDepositCids
          customerAmount <- getDepositQuantities customerDepositCids

          let failCalc : Text -> Update ()
              failCalc = \txt -> resolveMarkToMarketCalculation calculationCid CalculationFailed txt

              satisfyCalc : Text -> Update ()
              satisfyCalc = \txt -> resolveMarkToMarketCalculation calculationCid CalculationSatisfied txt

          if
            | mtmAmount == 0.0 -> satisfyCalc "" >> return None
            | mtmAmount > 0.0  ->
              if providerAmount < mtmAmount
              then failCalc "" >> return None
              else do
                satisfyCalc ""
                Some <$> exercise self TransferFromProvider with amount = mtmAmount; depositCids = providerDepositCids
            | otherwise ->
              if customerAmount < abs mtmAmount
              then failCalc "" >> return None
              else do
                satisfyCalc ""
                Some <$> exercise self TransferToProvider with amount = abs mtmAmount; depositCids = customerDepositCids

      nonconsuming TransferFromProvider : (ContractId AssetDeposit, [ContractId AssetDeposit])
        with
          depositCids : [ContractId AssetDeposit]
          amount : Decimal
        do
          assertMsg "deposits are not enough to transfer from provider" =<< (>= amount) <$> getDepositQuantities depositCids
          (depositCid::remainingCids) <- mergeAndSplit depositCids amount
          flip (,) remainingCids <$> transferWithController depositCid clearingAccount

      -- TODO: check that the deposit cid matches the clearing account?
      nonconsuming TransferToProvider : (ContractId AssetDeposit, [ContractId AssetDeposit])
        with
          amount : Decimal
          depositCids : [ContractId AssetDeposit]
        do
          assertMsg "deposits are not enough to transfer to provider" =<< (>= amount) <$> getDepositQuantities depositCids
          (depositCid::remainingCids) <- mergeAndSplit depositCids amount
          flip (,) remainingCids <$> transferWithController depositCid ccpAccount

      nonconsuming TransferFromMargin : (ContractId AssetDeposit,[ContractId AssetDeposit])
        with
          marginDepositCids : [ContractId AssetDeposit]
          amount : Decimal
        do
          assertMsg "deposits are not enough to transfer from margin" =<< (>= amount) <$> getDepositQuantities marginDepositCids
          (depositCid::remainingCids) <- mergeAndSplit marginDepositCids amount
          flip (,) remainingCids <$> transferFromMarginAccount depositCid

      nonconsuming TransferToMargin : (ContractId AssetDeposit,[ContractId AssetDeposit])
        with
          depositCids : [ContractId AssetDeposit]
          amount : Decimal
        do
          assertMsg "deposits are not enough to transfer to margin" =<< (>= amount) <$> getDepositQuantities depositCids
          (depositCid::remainingCids) <- mergeAndSplit depositCids amount
          flip (,) remainingCids <$> transferToMarginAccount depositCid

    choice Terminate : ()
      with
        ctrl : Party
      controller ctrl
      do
        void $ archive . fst <$> fetchByKey @MemberStanding (provider,customer)

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
    ccpAccount : Account
  where
    signatory operator, provider

    controller customer can
      Accept : ContractId Service
        with
          clearingAccount : Account
          marginAccount : Account
        do
          create MemberStanding with marginSatisfied = True, mtmSatisfied = True, ..
          create Service with ..

      Decline : ()
        do
          return ()

    controller provider can
      Withdraw : ()
        do pure ()

template Request
  with
    customer : Party
    provider : Party
    clearingAccount : Account
    marginAccount : Account
  where
    signatory customer

    controller customer can
      Cancel : ()
        do pure ()

    controller provider can
      Reject : ()
        do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
        ccpAccount : Account
      controller operator, provider
      do
        create MemberStanding with marginSatisfied = True, mtmSatisfied = True, ..
        create Service with ..
