module Marketplace.Trading.Order (
    T
  , Request(..)
  , AckRequest(..)
  , RejectRequest(..)
  , CancelRequest(..)
  , AckCancel(..)
  , RejectCancel(..)
  , Order(..)
  , Fill(..)
) where

import qualified Marketplace.BinaryOption as BinaryOption
import Marketplace.Transfer (DepositCreditRequest, DepositCreditRequest(..))
import DA.Finance.Types (Asset, Account, Id(..))
import Marketplace.Utils (IdPair, getAccountLabel)
import Marketplace.Token (Token)
import Marketplace.Trading.Trade (Trade, Trade(..))
import DA.Math ((**))

type T = Order

template Request
  with
    order : Order
  where
    signatory order.exchange, order.exchParticipant
    ensure order.qty > 0.0

    controller order.exchange can
      AckRequest : ContractId Order
        with
          orderId : Int
        do create order with orderId = orderId

      RejectRequest : ContractId DepositCreditRequest
        do
          create DepositCreditRequest with
            owner = order.exchParticipant
            account = order.account
            asset = order.asset


template CancelRequest
  with
    order : Order
  where
    signatory order.exchange, order.exchParticipant

    key (order.exchange, order.orderId) : (Party, Int)
    maintainer key._1

    controller order.exchange can
      AckCancel : ContractId DepositCreditRequest
        do exerciseByKey @Order (order.exchange, order.orderId) Cancel

      RejectCancel : ()
        do return ()

template Order
  with
    exchange : Party
    exchParticipant : Party
    pair : IdPair
    isBid : Bool
    price : Decimal
    qty : Decimal
    asset : Asset
    account : Account
    status : Text
    orderId : Int
  where
    let tokenObservers = if isBid
                         then pair._2.signatories
                         else pair._1.signatories
    signatory exchange, exchParticipant
    observer tokenObservers
    ensure qty > 0.0

    key (exchange, orderId) : (Party, Int)
    maintainer key._1

    controller exchange can
      FillBinaryOption : (ContractId Trade, Optional (ContractId Order))
        with
          fillQty : Decimal
          fillPrice : Decimal
          counterParty : Party
          counterOrderId : Int
          timestamp : Text
        do
          assert $ fillQty > 0.0
          assert $ fillQty <= qty
          assert $ if isBid then fillPrice <= price
                            else fillPrice >= price
          let receiverAccountId = Id
                with signatories = account.id.signatories,
                      label = getAccountLabel counterParty exchange, version = 0
              isBinaryOption = True
          (_, binOption) <- fetchByKey @BinaryOption.T pair._1
          (_, quoteToken) <- fetchByKey @Token pair._2
          if fillQty < qty then do
            let depositFillQty = roundBankers quoteToken.quantityPrecision $
                                    if isBid then fillQty * fillPrice
                                    else fillQty * (binOption.maxPrice - fillPrice)
            let [filledAsset, restAsset] = assetSplit asset [depositFillQty]
            remainingCid <- create this
              with qty = qty - fillQty, status = "PartiallyFilled", asset = restAsset
            tradeCid <- create Trade with
                isBuy = isBid, optAsset = Some filledAsset
                qty = fillQty, price = fillPrice, ..

            return $ (tradeCid, Some remainingCid)
          else do
            tradeCid <- create Trade with isBuy = isBid, optAsset = Some asset, price = fillPrice, ..
            return $ (tradeCid, None)

      Fill : (ContractId Trade, Optional (ContractId Order))
        with
          fillQty : Decimal
          fillPrice : Decimal
          counterParty : Party
          counterOrderId : Int
          timestamp : Text
        do
          assert $ fillQty > 0.0
          assert $ fillQty <= qty
          assert $ if isBid then fillPrice <= price
                            else fillPrice >= price

          let receiverAccountId = Id
                with signatories = account.id.signatories,
                      label = getAccountLabel counterParty exchange, version = 0
              isBinaryOption = False
          (_, baseToken) <- fetchByKey @Token pair._1
          (_, quoteToken) <- fetchByKey @Token pair._2
          if fillQty < qty then do
            let minFillQty = 10.0 ** (- intToDecimal if isBid then quoteToken.quantityPrecision
                                                              else baseToken.quantityPrecision)
            let depositFillQty = min (if isBid
                                      then roundBankers quoteToken.quantityPrecision $ fillQty * fillPrice
                                      else fillQty)
                                     (asset.quantity - minFillQty)
            if (depositFillQty > 0.0 && depositFillQty < asset.quantity)
            then do
              let [filledAsset, restAsset] = assetSplit asset [depositFillQty]

              remainingCid <- create this
                with qty = qty - fillQty, status = "PartiallyFilled"
                     asset = restAsset

              tradeCid <- create Trade with
                  isBuy = isBid, optAsset = Some filledAsset
                  qty = fillQty, price = fillPrice, ..

              return $ (tradeCid, Some remainingCid)
            else do
              -- the fillQty is not enough to warrant a deposit transfer
              remainingCid <- create this with qty = qty - fillQty, status = "PartiallyFilled"
              tradeCid <- create Trade with
                  isBuy = isBid, optAsset = None
                  qty = fillQty, price = fillPrice, ..

              return $ (tradeCid, Some remainingCid)
          else do
            tradeCid <- create Trade with
                isBuy = isBid, optAsset = Some asset
                price = fillPrice, ..

            return $ (tradeCid, None)

      Cancel : ContractId DepositCreditRequest
        do
          create DepositCreditRequest with
            owner = exchParticipant
            account = account
            asset = asset

    controller exchParticipant can
      nonconsuming RequestCancel : ContractId CancelRequest
        do create CancelRequest with order = this

assetSplit : Asset -> [Decimal] -> [Asset]
assetSplit asset quantities = map (\q -> asset with quantity = q) quantitiesAll
  where
    quantitySum = foldl (+) 0.0 quantities
    quantitiesAll = if quantitySum == asset.quantity
                    then quantities
                    else quantities ++ [asset.quantity - quantitySum]

