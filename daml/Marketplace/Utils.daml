module Marketplace.Utils where

import DA.Finance.Asset
import DA.Finance.Types

import DA.List (null,head,tail)
import DA.Next.Set hiding (null)
import DA.Optional
import DA.Text


type IdPair = (Id, Id)

data MarketRole = CustodianRole | IssuerRole | ExchangeRole | InvestorRole | BrokerRole | CCPRole
    deriving (Show, Eq)


template ExberrySID
  with
    exchange : Party
    sid      : Int
  where
    signatory exchange

    controller exchange can
      ExberrySID_Ack : ()
        do return ()


getAccountId : Party -> Party -> [Party] -> Id
getAccountId owner provider signatories = Id with
    signatories = fromList signatories
    label = getAccountLabel owner provider
    version = 0


getAccountLabel : Party -> Party -> Text
getAccountLabel owner provider = show owner <> "@" <> show provider


getAccountOwnerProvider: Text -> (Party, Party)
getAccountOwnerProvider label =
  let [owner, provider] = map (fromSome . partyFromText . replace "'" "") (splitOn "@" label)
  in (owner, provider)

getDepositQuantities : [ContractId AssetDeposit] -> Update (Decimal)
getDepositQuantities depositCids = do
  foldl (+) 0.0 <$> forA depositCids (\dcid -> do
      d <- fetch dcid
      return d.asset.quantity)

splitDecimals : Decimal -> [Decimal] -> [Decimal]
splitDecimals qty quantities = quantitiesAll
  where
    quantitySum = foldl (+) 0.0 quantities
    quantitiesAll =
                if quantitySum == qty
                then quantities
                else quantities ++ [qty - quantitySum]


-- getEnoughDeposits : Decimal -> ([Decimal], [Decimal]) -> Optional ([Decimal],[Decimal])
-- getEnoughDeposits restFunds (use,remaining)
--   | restFunds > 0.0 && null remaining = None
--   | restFunds <= 0.0 = Some (use,remaining)
--   | otherwise = getEnoughDeposits (restFunds - head remaining) (((head remaining) :: use),(tail remaining))

headNote : Text -> [a] -> a
headNote msg [] = error ("headNote: " <> msg)
headNote _ xs   = head xs

