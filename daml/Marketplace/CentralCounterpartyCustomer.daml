module Marketplace.CentralCounterpartyCustomer where

import qualified DA.Next.Set as Set

import Marketplace.Clearing
import Marketplace.Notification
import Marketplace.Transfer
import Marketplace.Utils

import DA.Finance.Asset
import DA.Finance.Asset.Settlement
import DA.Finance.Types

import DA.Action
import DA.List
import DA.Optional


template CCPCustomerInvitation
  with
    operator : Party
    ccp : Party
    ccpCustomer : Party
    custodian : Party
  where
    signatory ccp

    controller ccpCustomer can
      CCPCustomerInvitation_Accept : ContractId CCPCustomer
        do
          let custodianAccountId = getAccountId ccpCustomer custodian [custodian]
              accountId = getAccountId ccpCustomer ccp [custodian]

              custodianAccount = Account
                with id = custodianAccountId, provider = custodian, owner = ccpCustomer

              ccpAccount = Account
                with id = accountId, provider = ccp, owner = ccpCustomer

          create DismissibleNotification with
            sender = ccpCustomer, senderRole = Some InvestorRole
            receiver = ccp, text = "CCP customer invitation accepted."
          create CCPCustomer with inGoodStanding = True, marginDepositCids = [], ..

      CCPCustomerInvitation_Reject : ()
        do
          create DismissibleNotification with
            sender = ccpCustomer, senderRole = Some InvestorRole
            receiver = ccp, text = "CCP customer invitation rejected."
          return ()


template CCPCustomer
  with
    operator : Party
    ccp : Party
    custodian : Party
    ccpCustomer : Party
    -- clearingDepositCids : [ContractId AssetDeposit]
    marginDepositCids : [ContractId AssetDeposit]
    inGoodStanding : Bool
  where
    signatory ccp, ccpCustomer

    key (ccp, operator, ccpCustomer) : (Party, Party, Party)
    maintainer key._1

    controller ccp can
      CCPCustomer_PerformMarginFill : ContractId CCPCustomer
        with
          clearingDepositCids : [ContractId AssetDeposit]
          targetAmount : Decimal
          calculationCid : ContractId MarginCalculation
        do
          assertMsg "there must be a clearing deposit" $ not $ null clearingDepositCids
          clearingDepositCid <- exercise (head clearingDepositCids) AssetDeposit_Merge
              with depositCids = tail clearingDepositCids

          marginQuantity <- getDepositQuantities marginDepositCids
          let netDiff =  targetAmount - marginQuantity

          case netDiff of
            0.0    -> create this
            amount -> do
              if amount > 0.0
              then do
              --exercise self CCPCustomer_TransferToMarginAccount with amount, clearingDepositCid
                -- (custCcpRelationshipCid,_) <- fetchByKey @CCPCustodianRelationship (custodian, ccp)
                clearingDeposit <- fetch clearingDepositCid
                if clearingDeposit.asset.quantity <= amount
                then create this with inGoodStanding = False
                else do
                  newDepositCids <- exercise clearingDepositCid AssetDeposit_Split with quantities = [amount]
                  case newDepositCids of
                    []               -> exercise calculationCid MarginCalculation_Resolve { note = "not enough cash" } >> create this with inGoodStanding = False
                    [diffDepositCid] -> exercise calculationCid MarginCalculation_Resolve { note = "not enough cash" } >> create this with inGoodStanding = False
                    (diffDepositCid::remainingClearingCids) -> do
                      case marginDepositCids of
                        [] -> do
                          exercise calculationCid MarginCalculation_Resolve { note = "good job" }
                          create this with marginDepositCids = [diffDepositCid]
                        xs -> do
                          exercise calculationCid MarginCalculation_Resolve { note = "good job" }
                          newMarginDepositCid <- exercise (head xs) AssetDeposit_Merge with depositCids = diffDepositCid :: tail xs
                          create this with marginDepositCids = [newMarginDepositCid]
              else do -- exercise self CCPCustomer_TransferFromMarginAccount with amount = amount * (-1.0), clearingDepositCid
                assertMsg "no margin account found" $ not $ null marginDepositCids
                marginDepositCid <- exercise (head marginDepositCids) AssetDeposit_Merge
                    with depositCids = tail clearingDepositCids
                marginDeposit <- fetch marginDepositCid

                assertMsg ("amount to transfer: " <> show amount <> " exceeds amount in margin account: " <> show marginDeposit.asset.quantity)
                  $ amount < marginDeposit.asset.quantity
                -- move money from margin account to clearing account
                [diffDepositCid, remainingMarginDepositCid] <- exercise marginDepositCid AssetDeposit_Split
                    with quantities = [amount]
                newClearingDepositCid <- exercise clearingDepositCid AssetDeposit_Merge with depositCids = [diffDepositCid]
                exercise calculationCid MarginCalculation_Resolve { note = "good job" }
                create this with marginDepositCids = [remainingMarginDepositCid]

      CCPCustomer_TransferFromClearingAccount : (ContractId DepositTransferRequest, ContractId CCPCustomer)
        with
          clearingDepositCids : [ContractId AssetDeposit]
          amount : Decimal
          optMarkToMarketCalc : Optional (ContractId MarkToMarketCalculation)
        do
          assertMsg "there must be at least one clearing deposit" $ not $ null clearingDepositCids
          clearingDepositCid <- exercise (head clearingDepositCids) AssetDeposit_Merge
              with depositCids = tail clearingDepositCids

          clearingDeposit <- fetch clearingDepositCid
          [transferDepositCid, remainingDepositCid] <- exercise clearingDepositCid AssetDeposit_Split
              with quantities = [amount]

          let receiverAccountId = Id with
                signatories = clearingDeposit.account.id.signatories, label = getAccountLabel ccp custodian, version = 0

          depositTransferReqCid <- create DepositTransferRequest with
              sender = ccpCustomer, senderAccountId = clearingDeposit.account.id, depositCid = transferDepositCid, ..

          when (isSome optMarkToMarketCalc) $
            void $ exercise (fromSome optMarkToMarketCalc) MarkToMarketCalculation_Resolve with note = "resolved"

          (,) depositTransferReqCid <$> create this

      CCPCustomer_TransferToClearingAccount : ContractId CCPCustomer
        with
          depositCids : [ContractId AssetDeposit]
          amount : Decimal
        do
          assertMsg ("depositCids must not be empty in TransferToClearingAccount") $ not $ null depositCids
          aggregateQty <- getDepositQuantities depositCids
          assertMsg ("amount should be less than or equal to total deposit amount") $ amount <= aggregateQty

          mergedCid <- exercise (head depositCids) AssetDeposit_Merge with depositCids = tail depositCids
          deposit <- fetch mergedCid

          newDepositCid <- if amount < deposit.asset.quantity
                  then headNote "transferToClearing" <$> exercise mergedCid AssetDeposit_Split with quantities = [ amount ]
                  else return mergedCid
          newDeposit <- fetch newDepositCid

          let receiverAccountId = Id with
                signatories = newDeposit.account.id.signatories, label = getAccountLabel ccpCustomer ccp, version = 0

          depositTransferReqCid <- create DepositTransferRequest with
              sender = ccp, senderAccountId = newDeposit.account.id, depositCid = newDepositCid, ..

          create this
