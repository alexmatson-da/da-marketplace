module Marketplace.CentralCounterpartyCustomer where

import qualified DA.Next.Set as Set

import Marketplace.Notification
import Marketplace.Transfer
import Marketplace.Utils

import DA.Finance.Asset
import DA.Finance.Asset.Settlement
import DA.Finance.Types
import DA.List


template CCPCustomerInvitation
  with
    operator : Party
    ccp : Party
    ccpCustomer : Party
    custodian : Party
  where
    signatory ccp

    controller ccpCustomer can
      CCPCustomerInvitation_Accept : ContractId CCPCustomer
        do
          let custodianAccountId = getAccountId ccpCustomer custodian [custodian]
              accountId = getAccountId ccpCustomer ccp [custodian]

              custodianAccount = Account
                with id = custodianAccountId, provider = custodian, owner = ccpCustomer

              ccpAccount = Account
                with id = accountId, provider = ccp, owner = ccpCustomer

          create DismissibleNotification with
            sender = ccpCustomer, senderRole = Some InvestorRole
            receiver = ccp, text = "CCP customer invitation accepted."
          create CCPCustomer with inGoodStanding = True, clearingDepositCids = [], marginDepositCids = [], ..

      CCPCustomerInvitation_Reject : ()
        do
          create DismissibleNotification with
            sender = ccpCustomer, senderRole = Some InvestorRole
            receiver = ccp, text = "CCP customer invitation rejected."
          return ()


template CCPCustomer
  with
    operator : Party
    ccp : Party
    custodian : Party
    ccpCustomer : Party
    clearingDepositCids : [ContractId AssetDeposit]
    marginDepositCids : [ContractId AssetDeposit]
    inGoodStanding : Bool
  where
    signatory ccp, ccpCustomer

    key (ccp, operator, ccpCustomer) : (Party, Party, Party)
    maintainer key._1

    controller ccp can
      CCPCustomer_PerformMarginFill : ContractId CCPCustomer
        with
          targetAmount : Decimal
        do
          assertMsg "there must be a clearing deposit" $ not $ null clearingDepositCids
          clearingDepositCid <- exercise (head clearingDepositCids) AssetDeposit_Merge
              with depositCids = tail clearingDepositCids

          marginQuantity <- getDepositQuantities marginDepositCids
          let netDiff =  targetAmount - marginQuantity

          case netDiff of
            0.0    -> create this
            amount -> do
              if amount > 0.0
              then do
              --exercise self CCPCustomer_TransferToMarginAccount with amount, clearingDepositCid
                (custCcpRelationshipCid,_) <- fetchByKey @CCPCustodianRelationship (custodian, ccp)
                clearingDeposit <- fetch clearingDepositCid
                if clearingDeposit.asset.quantity <= amount
                then create this with inGoodStanding = False
                else do
                  newDepositCids <- exercise clearingDepositCid AssetDeposit_Split with quantities = [amount]
                  case newDepositCids of
                    []               -> create this with inGoodStanding = False
                    [diffDepositCid] -> create this with inGoodStanding = False, clearingDepositCids = [diffDepositCid]
                    (diffDepositCid::remainingClearingCids) -> do
                      case marginDepositCids of
                        [] -> do
                          create this with clearingDepositCids = remainingClearingCids, marginDepositCids = [diffDepositCid]
                        xs -> do
                          newMarginDepositCid <- exercise (head xs) AssetDeposit_Merge with depositCids = diffDepositCid :: tail xs
                          create this with clearingDepositCids = remainingClearingCids, marginDepositCids = [newMarginDepositCid]
              else do -- exercise self CCPCustomer_TransferFromMarginAccount with amount = amount * (-1.0), clearingDepositCid
                assertMsg "no margin account found" $ not $ null marginDepositCids
                marginDepositCid <- exercise (head marginDepositCids) AssetDeposit_Merge
                    with depositCids = tail clearingDepositCids
                marginDeposit <- fetch marginDepositCid

                assertMsg ("amount to transfer: " <> show amount <> " exceeds amount in margin account: " <> show marginDeposit.asset.quantity)
                  $ amount < marginDeposit.asset.quantity
                -- move money from margin account to clearing account
                [diffDepositCid, remainingMarginDepositCid] <- exercise marginDepositCid AssetDeposit_Split
                    with quantities = [amount]
                newClearingDepositCid <- exercise clearingDepositCid AssetDeposit_Merge with depositCids = [diffDepositCid]
                create this with clearingDepositCids = [newClearingDepositCid], marginDepositCids = [remainingMarginDepositCid]

      -- CCPCustomer_TransferToMarginAccount : ContractId CCPCustomer
      --   with
      --     amount : Decimal
      --     clearingDepositCid : ContractId AssetDeposit
      --   do

      -- CCPCustomer_TransferFromMarginAccount : ContractId CCPCustomer
      --   with
      --     amount : Decimal
      --     clearingDepositCid : ContractId AssetDeposit
      --   do

      CCPCustomer_TransferFromClearingAccount : (ContractId DepositTransferRequest, ContractId CCPCustomer)
        with
          amount : Decimal
        do
          clearingDepositCid <- exercise (head clearingDepositCids) AssetDeposit_Merge
              with depositCids = tail clearingDepositCids

          clearingDeposit <- fetch clearingDepositCid
          [transferDepositCid, remainingDepositCid] <- exercise clearingDepositCid AssetDeposit_Split
              with quantities = [amount]

          let receiverAccountId = Id with
                signatories = clearingDeposit.account.id.signatories, label = getAccountLabel ccp custodian, version = 0

          depositTransferReqCid <- create DepositTransferRequest with
              sender = ccpCustomer, senderAccountId = clearingDeposit.account.id, depositCid = transferDepositCid, ..

          (,) depositTransferReqCid <$> create this with clearingDepositCids = [remainingDepositCid]

      CCPCustomer_TransferToClearingAccount : ContractId CCPCustomer
        with
          depositCids : [ContractId AssetDeposit]
          amount : Decimal
        do
          assertMsg ("depositCids must not be empty in TransferToClearingAccount") $ not $ null depositCids
          aggregateQty <- getDepositQuantities depositCids
          assertMsg ("amount should be less than or equal to total deposit amount") $ amount <= aggregateQty

          mergedCid <- exercise (head depositCids) AssetDeposit_Merge with depositCids = tail depositCids
          deposit <- fetch mergedCid

          newDepositCid <- if amount < deposit.asset.quantity
                  then headNote "transferToClearing" <$> exercise mergedCid AssetDeposit_Split with quantities = [ amount ]
                  else return mergedCid
          newDeposit <- fetch newDepositCid

          let receiverAccountId = Id with
                signatories = newDeposit.account.id.signatories, label = getAccountLabel ccpCustomer ccp, version = 0

          depositTransferReqCid <- create DepositTransferRequest with
              sender = ccp, senderAccountId = newDeposit.account.id, depositCid = newDepositCid, ..

          create this

      CCPCustomer_AddDepositToClearingDeposits : ContractId CCPCustomer
        with
          depositCid : ContractId AssetDeposit
        do
          assertMsg "deposit cid already exists" $ depositCid `notElem` clearingDepositCids
          -- mergedCid <- exercise depositCid AssetDeposit_Merge with depositCids = clearingDepositCids
          create this with clearingDepositCids = depositCid :: clearingDepositCids

      -- CCPCustomer_TransferToClearingAccount : (ContractId DepositTransferRequest, ContractId CCPCustomer)
      --   with
      --     assetDepositCid : Decimal
      --   do



template CCPCustodianRelationshipRequest
  with
    operator : Party
    custodian : Party
    ccp : Party
  where
    signatory ccp

    -- TODO: Move to custodian relationship request
    controller custodian can
      CCPCustodianRelationshipRequest_Approve : ContractId CCPCustodianRelationship
        do
          create CCPCustodianRelationship
            with operator, custodian, ccp

template CCPCustodianRelationship
  with
    operator : Party
    custodian : Party
    ccp : Party
  where
    signatory custodian, ccp
    key (custodian, ccp) : (Party, Party)
    maintainer key._1

    controller ccp can
      nonconsuming CCPCustodianRelationship_CreateSettlementRule : ContractId AssetSettlementRule
        with
          account : Account
          observers : Set.Set Party
          ctrls : Set.Set Party
        do
          create AssetSettlementRule
            with account, observers, ctrls
